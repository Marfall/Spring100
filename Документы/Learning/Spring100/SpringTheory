https://github.com/in28minutes/spring-master-class

Spring is a Dependency Injection Framework

TYPICAL CODE:

public class ComplexBusinessService {

    SortAlgorithm sortAlgorithm = new BubbleSortAlgorithm();

    // if we want to use another sortAlgorithm, we must modify the code    
    // tight coupling
}

public class BubbleSortAlgorithm implements SortAlgorithm  {

}

REMOVE TIGHT COUPLING:

public class ComplexBusinessService {

    SortAlgorithm sortAlgorithm;

   public ComplexBusinessService(SortAlgorithm sortAlgorithm) {
       this.sortAlgorithm = sortAlgorithm;
   }
}

=> We can write this code:

    //loosely coupled programming 

    SortAlgorithm sortAlgorithm = new SortAlgorithm();
    ComplexBusinessService businessService = 
        new ComplexBusinessService(sortAlgorithm);
        
        
    Spring Framework instantiating  objects and  populate dependencies

    So, your job as a programmer  to tell the Spring  Framework what are the objects it would need 
    to manage and what are the dependencies of each class.


    @Component
    public class ComplexBusinessService {

        @Autowired
        SortAlgorithm sortAlgorithm;
    }

    @Component
    public class BubbleSortAlgorithm implements SortAlgorithm{

    }

    @Component  - tells Spring to start managing it's class instances

    @Autowired  - Spring starts looking for this dependency to fing a matching thing 

    - Spring would make sure that the instances of all the objects it manages
      are created with the dependencies properly populated.

      TERMINOLOGY:

            1) BEANS  -  objects, managing by Spring Framework

            2) AUTOWIRING  - the process where Spring identifies the dependencies,
                            identifies the matches for the dependencies and populates them;

            3) DEPENDENCY INJECTION   - injecting one component to another as a dependency

            4) INVERSION OF CONTROL   - Spring creates an instances 

            5) IOC CONTAINER  -   is a generic terminology to represent anything that is 
                                  implementing inversion of CONTROL

            6) APPLICATION CONTEXT  - IoC Container in Spring Framework


    USING INTERFACES FOR LOOSELY COUPLING:

        public interface SortAlgorithm {
            int[] sort(int[] numbers);
        }

        public class BubbleSortAlgorithm implements SortAlgorithm {
            public int[] sort(int[] numbers) {
                //Logic for Bubble Sort
                return numbers;
            }
        }

        public class BinarySearchImpl {

            private  SortAlgorithm sortAlgorithm;

            public BinarySearchImpl(SortAlgorithm sortAlgorithm) {
                this.sortAlgorithm = sortAlgorithm;
            }

            public int binarySearch(int[] numbers, int numberToSearchFor) {

                int[] sortedNumbers = sortAlgorithm.sort(numbers);
                System.out.println(sortAlgorithm);
                //Search in array
                return 3;
            }
        }

        @SpringBootApplication
        public class Spring100Application {

            public static void main(String[] args) {

                BinarySearchImpl binarySearch = new BinarySearchImpl(new BubbleSortAlgorithm());
                int result = binarySearch.binarySearch(new int[] {12, 4, 6, }, 3);
                System.out.println(result);
                
                SpringApplication.run(Spring100Application.class, args);
            }
        }

        =>  SortAlgorithm -  is a dependency of BinarySearch.
            BinarySearch depends of the SortAlgorithm.
            We male a SortAlgorithm as a separate dependency and passing it 
            into the BinarySearch.
            Then we create an instance of binarySearchImpl and create an instance of quickSort
            and pass it in.


    The most important concepts behind Spring are:
        - Dependency Injection
        - Loose Coupling

    3 questions for begin in Spring Framework:

        - What are te beans?
        - What are the dependencies for the beans
        - Where to search for beans

    @SpringBootApplication - Spring Boot would automatically scan the package (and subpackages) for the beans, where the main
                             application class us present.


    SpringApplication.run(Spring100Application.class, args);

        - run Spring Boot Application, returns ApplicationContext

        => we can make a local variable from it:

    ApplicationContext applicationContext = SpringApplication.run(Spring100Application.class, args);

    BinarySearchImpl binarySearch = applicationContext.getBean(BinarySearchImpl.class);

        - get bean from ApplicationContext


    logging.level.org.springframework = debug
        -set logging level in application.properties


    Also, Spring is searching for beans and their dependencies with  Component Scan.


    DYNAMIC AUTOWIRING AND TROUBLESHOOTING. @PRIMARY:

    - Whenever you have any problems of the type 
        "a bean is not found" or
        "multiple beans are found"

    => See if you have used the right combination of component, autowired and primary. 



    CONSTRUCTOR AND SETTER INJECTION:

        Mandatory Dependency:
            - it is a dependency which it can't work without
            - another - optional dependencies

        If we have mandatory dependencies - the recommendation is
        to use Constructor Injection

        For optional dependencies, recommendation is Setter Injection


    SPRING PROJECTS:

        - Spring Batch
        - Spring Boot
        - Spring Cloud
        - Spring Data
        - Spring Integration
        - Spring Security
        - Spring HATEOAS

    SPRING ADVATAGES:

        - Enables Testable Code
        - No Plumbuing Code
        - Flexible Archicture
        - Staying Current


    DEPENDENCIES EXAMPLES:

        @Component
        public class ToDoController {

            @Autowired
            ToDoBusinessService businessService;
        }

        @Component
        public class ToDoBusinessService {

            @Autowired
            ToDoDataService dataservice;
        }

        @Component
        public class ToDoDataService {

            @Autowired
            JdbcTemplate template;
        }


    AUTOWIRING BY NAME AND PRIMARY:

        @Autowired
        private  SortAlgorithm sortAlgorithm;

        =>

        @Autowired
        private  SortAlgorithm bubleSortAlgorithm;   - variable is a name of class 


    QUALIFIER:

        @Component
        public class BinarySearchImpl {

            @Autowired
            @Qualifier("quick")
            private  SortAlgorithm sortAlgorithm;


            public int binarySearch(int[] numbers, int numberToSearchFor) {

                int[] sortedNumbers = sortAlgorithm.sort(numbers);
                System.out.println(sortAlgorithm);
        
                return 3;
            }
        }


        @Component
        @Qualifier("quick")
        public class QuickSortAlgorithm implements SortAlgorithm {
            public  int[] sort(int[] numbers) {
                
                return numbers;
            }
        }

        => 3 options to resolving multiple candidates for autowiring:

            - Name 
            - @Qualifier
            - @Primary        //recommended way
 

    BEAN SCOPE:

        - Singleton - One instance per Spring Context 
        - Prototype - New bean whenever requested
        - Request - One bean per HTTP request
        - Session - One bean per HTTP session

         Default - Singleton

            @Component
            @Scope("prototype")
            public class BinarySearchImpl {
            }

            Hardcoding "prototype" is not good practice,
            Use ConfigurableBeanFactory:

            @Component
            @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
            public class BinarySearchImpl {
            }


    SLFJ LOGGER:

        private  static Logger LOGGER = LoggerFactory.getLogger(Spring100ScopeApplication.class);


        @SpringBootApplication
        public class Spring100ScopeApplication {

            private  static Logger LOGGER = LoggerFactory.getLogger(Spring100ScopeApplication.class);

            public static void main(String[] args) {

                ApplicationContext applicationContext =
                        SpringApplication.run(Spring100ScopeApplication.class, args);

                PersonDAO personDao = applicationContext.getBean(PersonDAO.class);

                PersonDAO personDao2 = applicationContext.getBean(PersonDAO.class);

                LOGGER.info("{}",personDao);
                LOGGER.info("{}",personDao.getJdbcConnection());

                LOGGER.info("{}",personDao2);
                LOGGER.info("{}",personDao2.getJdbcConnection());
            }
        }

        CBF + TAB = ConfigurableBeanFactory


        @Component
        public class PersonDAO {

            @Autowired
            JdbcConnection jdbcConnection;

            public JdbcConnection getJdbcConnection() {
                return jdbcConnection;
            }

            public void setJdbcConnection(JdbcConnection jdbcConnection) {
                this.jdbcConnection = jdbcConnection;
            }
        }


        @Component
        @Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE, proxyMode = ScopedProxyMode.TARGET_CLASS)
        public class JdbcConnection {

            public JdbcConnection() {
                System.out.println("JDBC Connection ");
            }
        }

        proxyMode = ScopedProxyMode.TARGET_CLASS

            - create a new object in every request  (proxy)

            => every time , when JdbcConnection is used, it would start using a proxy
               and whenever there is a request, you make sure that there is a new JdbcConnection beeing used.


        => When you trying to get a singleton - bean and one of it's dependencies is a prototype,
           then on the dependency, we should use a proxy.



    DIFFERENCE BETWEEN SPRING SINGLETON AND  GOF SINGLETON:

        - GOF Singleton means - One Singleton per JVM;
        - Spring Singleton -  One instance per Application Context


    USING COMPONENT SCAN:

        @SpringBootApplication includes:

            - @ComponentScan
            - @Configuration
            - @EnabeAutoConfiguration  


        - @ComponentScan("com.in28minutes,spring.basics")  - scan for components in package



    LIFECYCLE OF A BEAN - @PostConstruct and  @PreDestroy:

        - @PostConstruct would be called when the bean is created.
          So, as soon as the bean is created and initialized with the dependencies,
          the postConstruct method would be called.

        - @PreDestroy method called when the bean is removed out of context.
         

            @Component
            @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)
            public class BinarySearchImpl {

                private Logger logger = LoggerFactory.getLogger(this.getClass());

                @Autowired
                @Qualifier("quick")
                private  SortAlgorithm sortAlgorithm;
                
                public int binarySearch(int[] numbers, int numberToSearchFor) {

                    int[] sortedNumbers = sortAlgorithm.sort(numbers);
                    System.out.println(sortAlgorithm);
                    return 3;
                }

                @PostConstruct
                public void postConstruct() {
                    logger.info("postConstruct");
                }
                @PreDestroy
                public void preDestroy() {
                    logger.info("preDestroy");

                }
            }


    CDI - CONTEXT AND DEPENDENCY INJECTION:

        - Java EE Dependency Injection Standart (JSR-330) - ia an Interface defining how to do DI.
        - Spring supports CDI

        - @Inject (@Autowired).
        - @Named (@Component and @Qualifier)
        - @Singleton (Desines a scope of Singleton)
        
        Maven Dependency for CDI:

        <dependency>
            <groupId>javax.inject</groupId>
            <artifactId>javax.inject</artifactId>
            <version>1</version>
        </dependency>


    REMOVING SPRING BOOT IN APPLICATION:

        - removing spring boot starter dependency on spring-core and spring-context

            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter</artifactId>
            </dependency>       
            
            -   <dependency>
                    <groupId>org.springframework</groupId>
                    <artifactId>spring-core/artifactId>
                </dependency>
        
        - Add @Configuration, add ApllicationContext:
            AnnotationConfigApplicationContext = ACAC + TAB


            ApplicationContext applicationContext =
				new AnnotationConfigApplicationContext(Spring100BasicApplication.class);

        - Add ComponentScan:

            @ComponentScan("com.outspace.spring.spring100")

        - Add dependency for SLF4j:

            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-context</artifactId>
		    </dependency>

        - If @PostConstruct and @PreDestroy not working, add javax.annotation-api as dependency:

                <dependency>
                    <groupId>javax.annotation</groupId>
                    <artifactId>javax.annotation-api</artifactId>
                </dependency>



        ADD LOGBACK AND CLOSE APPLICATION CONTEXT:


            ConfigurableApplicationContext applicationContext =
				new AnnotationConfigApplicationContext(Spring100BasicApplication.class);

            applicationContext.close();


            another way - try-catch with resources:

            @Configuration
            @ComponentScan("com.outspace.spring.spring100")
            public class Spring100BasicApplication {

                public static void main(String[] args) {

                    try (ConfigurableApplicationContext applicationContext =
                            new AnnotationConfigApplicationContext(Spring100BasicApplication.class)) {

                        BinarySearchImpl binarySearch = applicationContext.getBean(BinarySearchImpl.class);
                        BinarySearchImpl binarySearch1 = applicationContext.getBean(BinarySearchImpl.class);

                        System.out.println(binarySearch);
                        System.out.println(binarySearch1);

                        int result = binarySearch.binarySearch(new int[]{12, 4, 6,}, 3);

                        System.out.println(result);
                    }
                }
            }


        - problem with log4j resolved with dependency:

                <dependency>
                    <groupId>ch.qos.logback</groupId>
                    <artifactId>logback-classic</artifactId>
                </dependency>



        DEFINING SPRING APPLICATION CONTEXT USING XML:

            -we  need to create applicationContext.xml in src/main/resources

            <?xml version="1.0" encoding="UTF-8"?>
            <beans xmlns="http://www.springframework.org/schema/beans"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
                
                <bean id="xmlJdbcConnection"
                    class="com.outspace.spring.spring100.xml.XMLJdbcConnection">
                </bean>
                <bean id="xmlPersonDAO"
                    class="com.outspace.spring.spring100.xml.XMLPersonDAO">
                    <property name="xmlJdbcConnection" ref="xmlJdbcConnection"/>
                </bean>
            </beans>

            public class XMLPersonDAO {
                
                XMLJdbcConnection xmlJdbcConnection;

                public XMLJdbcConnection getXmlJdbcConnection() {
                    return xmlJdbcConnection;
                }

                public void setXmlJdbcConnection(XMLJdbcConnection xmlJdbcConnection) {
                    this.xmlJdbcConnection = xmlJdbcConnection;
                }
            }

            public class XMLJdbcConnection {

                public XMLJdbcConnection() {
                    System.out.println("JDBC Connection ");
                }
            }


        MIXING XML CONEXT AND JAVA CONFIG:

            applicationContext.getBeanDefinitionNames();

                - What are the beans are loaded by this applicationContext


            LOGGER.info("Beans Loaded -> {}",
                        (Object)applicationContext.getBeanDefinitionNames());

                -  get an array of defined beans (without Object-casting - only one)

            
            CHANGE SCHEMA:

                <?xml version="1.0" encoding="UTF-8"?>
                <beans xmlns="http://www.springframework.org/schema/beans"
                    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                    xmlns:context="http://www.springframework.org/schema/context"
                    xsi:schemaLocation="http://www.springframework.org/schema/beans
                        http://www.springframework.org/schema/beans/spring-beans.xsd
                        http://www.springframework.org/schema/context
                        http://www.springframework.org/schema/context/spring-context.xsd">

                    <context:component-scan base-package="com.outspace.spring.spring100"/>

                    <bean id="xmlJdbcConnection"
                        class="com.outspace.spring.spring100.xml.XMLJdbcConnection">
                    </bean>
                    <bean id="xmlPersonDAO"
                        class="com.outspace.spring.spring100.xml.XMLPersonDAO">
                        <property name="xmlJdbcConnection" ref="xmlJdbcConnection"/>
                    </bean>
                </beans>


            IOC-CONTAINER, APPLICATION CONTEXT, BEAN FACTORY:

                IoC container - is a generic concept

                - There are 2 implementations of IoC in Spring:

                    - BeanFactory           - basic management for beans and wiring the dependencies
                    - ApplicationContext   // recommended

                        - BeanFactory++
                            - Spring's AOP  features
                            - |18n capabilities
                            - WebApplicationContext for web applications etc             
                            - provides Internationalization - can customize the text, based on the
                              locale of user


            @COMPONENT VS @SERVICE VS @REPOSITORY VS @CONTROLLER:

                @Component - Generic Component

                @Repository - encapsulating storage, retrieval and search behaviour typically
                            from a relational database.
                            Provides a default JDBC-exeptions translation facility.

                @Service - Business Service Facade
                            - With Sprong AOP you can identify and log all of the content that coming in.
                            

                @Controller - Controller in MVC pattern



        READ VALUES FROM  EXTERNAL PROPERTIES FILE:

            1) create file app.properties in resources and add something like:

                external.service.url=hhtp://someserver.dev.com/service
            
            2) add      @Value("${external.service.url}")
                        private String url;

                It's configuring when context is creating.
                @PropertySource("classpath:app.properties")   - defining properties source


                @Configuration
                @ComponentScan("com.outspace.spring.spring100")
                @PropertySource("classpath:app.properties")
                public class Spring100PropertiesApplication {

                    public static void main(String[] args) {

                        try (ConfigurableApplicationContext applicationContext =
                                new AnnotationConfigApplicationContext(Spring100PropertiesApplication.class)) {

                            SomeExternalService someExternalService =
                                    applicationContext.getBean(SomeExternalService.class);
                            
                            System.out.println("CURRENT URL: " + someExternalService.returnServiceURL());
                        }
                    }
                }

                @Service
                public class SomeExternalService {

                    // from property file external.service.url
                    @Value("${external.service.url}")
                    private String url;

                    public String returnServiceURL() {
                        return url;
                    }
                }


                

        JUNIT TESTING:

            - It's testing a specific method or a specific class or group of methods;

            @Test - method contains Unit Test

            import org.junit.jupiter.api.Test;

            import static org.junit.jupiter.api.Assertions.assertEquals;

            class MyMathTest {

                //MyMath.sum
                // 1,2,3 => 6

                @Test
                public  void sum_with3numbers() {
                    MyMath myMath = new MyMath();
                    int result = myMath.sum(new int[] {1, 2, 3});

                    //check that result is 6
                    //check result==6
                    
                    assertEquals(6, result);

                    System.out.println(result);
                }
            }


                @Test
                public void test() {
                    boolean cond = true;
                    assertEquals(true, cond);
                    assertTrue(cond);
                    assertFalse(cond);
                    assertNotNull(Object object);
                    assertArrayEquals(expecteds, actuals);
                }
            }
             

            @BeforeEach - will be running before every test

            @BeforeAll - it's a class annotation, runs one time for every class (and static method)



            import static org.junit.jupiter.api.Assertions.assertEquals;

            class MyMathTest {

                @BeforeEach
                public void before() {
                    System.out.println("Before test");
                }
                @AfterAll
                public static void after() {
                    System.out.println("After test");
                }
                @Test
                public  void sum_with3numbers() {
                    System.out.println("Test1");
                    MyMath myMath = new MyMath();
                    int result = myMath.sum(new int[] {1, 2, 3});
                    assertEquals(6, result);
                    System.out.println(result);
                }
                @Test
                public void sum_with1number() {
                    System.out.println("Test2");
                    assertEquals(3,new MyMath().sum(new int[] {3}));
                }
            }


        MOCKITO:

        When we are using Mocks we don't really need to create multiple versions to make it 
        really easy to dynamically create different classes and make them return the data
        that we would want to return.

            WITHOUT MOCK EXAMPLE:

                public class SomeBusinessTest {

                    @Test
                    public void testFindTheGreatestFromAllData() {

                        SomeBusinessImpl businessImpl = new SomeBusinessImpl(new DataServiceStub());
                        int result = businessImpl.findTheGreatestFromAllData();
                        assertEquals(24, result);
                    }
                }

                class DataServiceStub implements DataService {
                    @Override
                    public int[] retrieveAllData() {
                        return new int[] {4, 6, 15};
                    }
                }


        USING MOKITO:

            package com.mockito100.mockitodemo;

            import org.junit.jupiter.api.Test;

            import static org.junit.jupiter.api.Assertions.assertEquals;
            import static org.mockito.Mockito.mock;
            import static org.mockito.Mockito.when;

            public class SomeBusinessMockTest {

                @Test
                public void testFindTheGreatestFromAllData() {

                    DataService dataServiceMock = mock(DataService.class);

                    when(dataServiceMock.retrieveAllData()).thenReturn(new int[] {24, 15, 3});

                    SomeBusinessImpl businessImpl = new SomeBusinessImpl(dataServiceMock);
                    int result = businessImpl.findTheGreatestFromAllData();
                    assertEquals(24, result);
                }

                @Test
                public void testFindTheGreatestFromAllData_ForOneValue() {

                    DataService dataServiceMock = mock(DataService.class);

                    when(dataServiceMock.retrieveAllData()).thenReturn(new int[] {15});

                    SomeBusinessImpl businessImpl = new SomeBusinessImpl(dataServiceMock);
                    int result = businessImpl.findTheGreatestFromAllData();
                    assertEquals(24, result);
                }
            }





    MOCKITO ANNOTATIONS @MOCK, @INJECTMOKS, @RUNWITH:

        @Mock
        DataService dataServiceMock;    - this should be mocked

        - When you use Mockito-annotations, we would need to use a RunWith you want to run.

        @RunWith(MOckitoJUnitRunner)  or JUNIT5 - style @ExtendWith(SpringExtension.class)

        @ExtendWith(SpringExtension.class)
        public class SomeBusinessMockAnnotationTest {

            @Mock
            DataService dataServiceMock;

            @InjectMocks
            SomeBusinessImpl businessImpl;


            @Test
            public void testFindTheGreatestFromAllData() {

                when(dataServiceMock.retrieveAllData()).thenReturn(new int[] {24, 15, 3});
                int result = businessImpl.findTheGreatestFromAllData();
                assertEquals(24, result);
            }

            @Test
            public void testFindTheGreatestFromAllData_ForOneValue() {

                when(dataServiceMock.retrieveAllData()).thenReturn(new int[] {15});
                int result = businessImpl.findTheGreatestFromAllData();
                assertEquals(15, result);
            }
        }


    Mockito.anyInt()    - any integer value;
    -   If one parameter is generic, another parameters nust be generic too.

        public class ListTest {

        @Test
        public void testSize() {
                List listmock = mock(List.class);
                when(listmock.size()).thenReturn(10);
                assertEquals(10, listmock.size());
        }

        @Test
        public void testSize_multipleReturns() {
            List listmock = mock(List.class);
            when(listmock.size()).thenReturn(10).thenReturn(20);
            assertEquals(10, listmock.size());
            assertEquals(20, listmock.size());
            assertEquals(20, listmock.size());
        }

        @Test
        public void testGet_SpecifiParameter() {
            List listmock = mock(List.class);
            when(listmock.get(0)).thenReturn("SomeString");
            assertEquals("SomeString", listmock.get(0));
            assertEquals(null, listmock.get(1));
        }

        @Test
        public void testGet_GenericParameter() {
            List listmock = mock(List.class);
            when(listmock.get(Mockito.anyInt())).thenReturn("SomeString");
            assertEquals("SomeString", listmock.get(0));
            assertEquals("SomeString", listmock.get(1));
        }
    }



    UNIT TESTING WITH SPRING FRAMEWORK:

        <dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-test</artifactId>
			<scope>test</scope>
		</dependency>

		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<scope>test</scope>
		</dependency>

        <dependency>
			<groupId>org.mockito</groupId>
			<artifactId>mockito-core</artifactId>
			<scope>test</scope>
		</dependency>


        // Load the context
        @RunWith(SpringRunner.class)
        @ContextConfiguration(classes = Spring100BasicApplication.class)
        public class BinarySearchTest {


            // Get this bean from the context. When the context is loaded - the bean can be autowired
            @Autowired
            BinarySearchImpl binarySearch;

            @Test
            public  void testBasicScenario() {

            int actualResult = binarySearch.binarySearch(new int[]{}, 5);
            assertEquals(3, actualResult);
                // call method on binarySearch
                // check if the value is correct
            }
        }


    XML CONFIGURATION TEST:

        @RunWith(SpringRunner.class)
        @ContextConfiguration(locations = "/applicationContext.xml")   - for XML-test Config 


        <import resource="classpath:applicationContext.xml"/>   - overriding context



    SPRING UNIT TESTING WITH MOCKITO:

            @RunWith(MockitoJUnitRunner.class)
            public class SomeCdiBusinessTest {

                //Inject the Mock
                @InjectMocks
                SomeCDIBusiness business;

                // Create Mock
                @Mock
                SomeCDIDAO daoMock;

                @Test
                public  void testBasicScenario() {
                    Mockito.when(daoMock.getData()).thenReturn(new int[] {2 , 4});
                    //when daoMock.getData() is called, return int[]{2, 4}

                int actualResult = business.findGreates();
                assertEquals(4, actualResult);
                }
                @Test
                public  void testBasicScenario2() {

                    Mockito.when(daoMock.getData()).thenReturn(new int[] {2, 3});

                    int actualResult = business.findGreates();
                    assertEquals(3, actualResult);
                }

                @Test
                public  void testBasicScenario_NoElements() {

                    Mockito.when(daoMock.getData()).thenReturn(new int[] {});

                    int actualResult = business.findGreates();
                    assertEquals(Integer.MIN_VALUE, actualResult);
                }
            }



    SPRING BOOT:

        GOALS:

            - Enable building production ready applications quickly
            - Provide common non-functional features:
                - embedded servers
                - metrics
                - health checks
                - externalized configuration

            NO:
                - code generation
                - not a web/application servers

        FEATURES:

            - Quick Starter Projects with Auto Configuration:
                - Web
                - JPA
            - Embedded Servers:
                - Tomcat 
                - Jetty  
                - Undertow
            - Production-ready features:
                - metrics
                - health checks
                - externalized configuration

        SIMPLE REST CONTROLLER:

            @RestController
            public class BooksController {

                @GetMapping("/books")
                public List<Book> getAllBooks() {

                    return Arrays.asList(new Book(1L, "Masterinf Spring 5.0", "Ranga Karanam"));
                }
            }


        SPRING BOOT AUTOCONFIGURATION:

            @SpringBootApplication
            public class BootApplication {

                public static void main(String[] args) {
                    SpringApplication.run(BootApplication.class, args);
                }
            }

            @SpringBootApplication
    
                - this annotation indicates that this is a Spring Context file.
                - enables auto configuration
                - enables component scan

            SpringApplication.run() method - is used to run a Spring Context;

            run() method returns an ApplicationContext
            

            @SpringBootApplication
            public class BootApplication {

                public static void main(String[] args) {

                    ApplicationContext applicationContext =
                            SpringApplication.run(BootApplication.class, args);

                    for (String name : applicationContext.getBeanDefinitionNames()) {
                        System.out.println(name);
                    }
                }
            }

            - shows all beans from ApplicationContext

            Spring Boot looks at:

            1) Frameworks available on the classpath
            2) Existing configuration for the application.

            Based on there, Spring Boot provides basic configuration
            needed to configure the application with these frameworks.
            This is called Auto Configuration.

            
            Set up debug logging in application properties:

            logging.level.org.springframework - Debug


        SPRING BOOT ACTUATOR:

            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-actuator</artifactId>
            </dependency>

             - Actuator brings in a lot of monitoring around your application:
                - what are the beans are configured
                - how auto configuration has worked
                - how many times the specific service has called
                - how many times the specific service has failed
                
            HAL BROWSER:

                <dependency>
                    <groupId>org.springframework.data</groupId>
                    <artifactId>spring-data-rest-hal-browser</artifactId>
                </dependency>

            BASE URLs:  http://localhost:8080/actuator

                  http://localhost:8080/actuator/health

                  http://localhost:8080/actuator/info



            For including another we need to configure application properties:

            - management.endpoints.web.exposure.include=*

            http://localhost:8080/browser/index.html#/  - HAL BROWSER

            http://localhost:8080/browser/index.html#http://localhost:8080/actuator/metrics/jvm.memory.used

                - shows JVM memory in use


    SPRING BOOT DEVELOPERS TOOLS:

        <dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
		</dependency>



    SPRING AOP:

        - AOP is a best approach to implement cross-cutting concerns

        @SpringBootApplication
        public class SpringAopApplication  implements CommandLineRunner {

            private Logger logger = LoggerFactory.getLogger(this.getClass());

            @Autowired
            private Business1 business1;

            @Autowired
            private Business2 business2;

            public static void main(String[] args) {
                ConfigurableApplicationContext applicationContext =
                        SpringApplication.run(SpringAopApplication.class, args);
            }

            @Override
            public void run(String... args) throws Exception {
                logger.info(business1.calculateSomething());
                logger.info(business2.calculateSomething());
            }
        }

        - The run method os one of the things, which you need to implement, 
          defined in CommandLineRunner Interface.
        - As soon as we implement the run method whenever the spring Boot application launches up,
          it also calls the run() method.
        - And once the spring context is ready it would call launch up the
          command line runner and would be seeing the information , which is present in here.



    DEFINING AN @BEFORE ADVICE:

        execution(* PACKAGE.*.*(..))  

            - I want to intercept all methods irrespective of their return  type in a specific package,
              any class in a specific package and intercept all method calls irrespective of their 
              arguments.

        //AOP
        //Configuration
        @Configuration
        @Aspect
        public class UserAccessAspect {

            private Logger logger = LoggerFactory.getLogger(this.getClass());

            // What kind of method calls I would intercept
            // execution(* PACKAGE.*.*(..))
            @Before("execution(* com.spring100.spring.aop.springaop.business.*.*(..))")
            public void before(JoinPoint joinPoint) {
                logger.info("Intercepted Method Calls - {}", joinPoint);
            }
        }

        @Before annotation intercepts before the call has happened

        - For example it can be used if you want to check if a user has the right 
          to access and renaming this need to.

        @Configuration
        @Aspect
        public class UserAccessAspect {

            private Logger logger = LoggerFactory.getLogger(this.getClass());
            @Before("execution(* com.spring100.spring.aop.springaop.business.*.*(..))")
            public void before(JoinPoint joinPoint) {
                logger.info("Check for user access");
                logger.info("Allowed execution for- {}", joinPoint);
            }
        }



    ASPECT-ORIENTED TERMINOLOGY: POINTCUT, ADVICE, ASPECT and JOINPOINT:


        @Before("execution(* com.spring100.spring.aop.springaop..*.*(..))")

            - intercept all methods in package


        POINTCUT -  an expression which defines what kind of method I would
                    want to intercept

        ADVICE   -    what should I do when I do the interception - this logic called Advice.


        ASPECT   -   a combination of Pointcut and Advice

        JOINPOINT   -  is a specific interception of method call,
                       specific execution instance.

        WEAVING     - the process of implementing the AOP around your method calls

        WEAVER     - the framework  which does the entire logic of making sure thet the Aspect
                     is invoded the right point.



        USING @AFTER, @AfterReturning, @AfterThrowing advices:

            @Configuration
            @Aspect
            public class AfterAopAspect {

                private Logger logger = LoggerFactory.getLogger(this.getClass());
                @AfterReturning(
                        value = "execution(* com.spring100.spring.aop.springaop.business.*.*(..))",
                        returning = "result"
                )
                public void after(JoinPoint joinPoint, Object result) {
                    // Advice
                    logger.info("Check for user access");
                    logger.info("{} returned value {}", joinPoint,result);
                }

                @AfterThrowing(
                        value = "execution(* com.spring100.spring.aop.springaop.business.*.*(..))",
                        throwing = "exception"
                )
                public void afterThrowing(JoinPoint joinPoint, Exception exception) {
                    // Advice
                    logger.info("Check for user access");
                    logger.info("{} throw exception {}", joinPoint, exception);
                }

                @After(
                        value = "execution(* com.spring100.spring.aop.springaop.business.*.*(..))")
                public void after(JoinPoint joinPoint) {
                    // Advice
                    logger.info("Check for user access");
                    logger.info("after execution of {}", joinPoint);
                }
            }


            @AfterReturning will be executed only when the execution gets completed successfully



    USING @Around ADVICE ANNOTATION:

        - ProceedingJoinPoint would allow you ti continue with the execution
          of the method

            @Configuration
            @Aspect
            public class MethodExecutionCalculationAspect {

                private Logger logger = LoggerFactory.getLogger(this.getClass());

                @Around("execution(* com.spring100.spring.aop.springaop.business.*.*(..))")
                public void around(ProceedingJoinPoint joinPoint) throws Throwable {
                    long startTime = System.currentTimeMillis();
                    joinPoint.proceed();
                    long timeTaken = System.currentTimeMillis() - startTime;
                    logger.info("Time taken by {} is {}", joinPoint, timeTaken);
                }

            }


    BEST PRATICE - COMMON POINTCUT CONFIGURATION:

        public class CommonJoinPointConfig {

            @Pointcut("execution(* com.spring100.spring.aop.springaop.business.*.*(..))")
            public void dataLayerExecution() {

            }
        }

        @Configuration
        @Aspect
        public class UserAccessAspect {

            private Logger logger = LoggerFactory.getLogger(this.getClass());
            @Before("com.spring100.spring.aop.springaop.aspect.CommonJoinPointConfig.dataLayerExecution()")
            public void before(JoinPoint joinPoint) {
                // Advice
                logger.info("Check for user access");
                logger.info("Allowed execution for- {}", joinPoint);
            }
        }

        - That would help you in keeping all the pointciy at a single place

        - COMBINE EXECUTIONS:

              @Pointcut("com.spring100.spring.aop.springaop.aspect.CommonJoinPointConfig.businessLayerExecution()
                         && com.spring100.spring.aop.springaop.aspect.CommonJoinPointConfig.dataLayerExecution()")                                    public  void allLayerExecution() {}



            @Pointcut("bean(*dao*)")
            public void beanStartingWithDao() {}

            - so we are looking for containing dao this to look for any bean 
              which has the name dao in between

            public class CommonJoinPointConfig {

                @Pointcut("execution(* com.spring100.spring.aop.springaop.dao.*.*(..))")
                public void dataLayerExecution() {}

                @Pointcut("execution(* com.spring100.spring.aop.springaop.business.*.*(..))")
                public void businessLayerExecution() {}

                @Pointcut("com.spring100.spring.aop.springaop.aspect.CommonJoinPointConfig.businessLayerExecution() && com.spring100.spring.aop.springaop.aspect.CommonJoinPointConfig.dataLayerExecution()")
                public  void allLayerExecution() {}

                @Pointcut("bean(*dao*)")
                public void beanStartingWithDao() {}

                @Pointcut("within(com.spring100.spring.aop.springaop.business..")
                public void beanStartingWithDaoWithin() {}
            }   


    CREATING CUSTOM ANNOTATION AND AN ASPECT FOR TRACKING TIME:

        @Target(ElementType.METHOD)
        @Retention(RetentionPolicy.RUNTIME)
        public @interface TrackTime {
        }

        @Pointcut("@annotation(com.spring100.spring.aop.springaop.aspect.TrackTime)")
        public void trackTimeAnnotation() {}


        @Configuration
        @Aspect
        public class MethodExecutionCalculationAspect {

            private Logger logger = LoggerFactory.getLogger(this.getClass());

            @Around("com.spring100.spring.aop.springaop.aspect.CommonJoinPointConfig.trackTimeAnnotation()")
            public void around(ProceedingJoinPoint joinPoint) throws Throwable {
                long startTime = System.currentTimeMillis();
                joinPoint.proceed();
                long timeTaken = System.currentTimeMillis() - startTime;
                logger.info("Time taken by {} is {}", joinPoint, timeTaken);
            }
        }

    
    
    DATABASES, JDBC, JPA:

        LAUNCHING H2 CONSOLE:

            spring.h2.console.enabled=true
                - in application properties - enables H2 console

                - now console available at http://localhost:8080/h2-console 

                - create schema.sql file in resources:

                create table person
                (
                    id integer not null,
                    name varchar(255) not null,
                    location varchar(255),
                    birth_day timestamp,
                    primary key(id)
                );

                - create data.sql in resources:

                INSERT INTO person (id, name, location, birth_date)
                VALUES(10001, 'Ranga', 'Hyderabad',sysdate());
                INSERT INTO person (id, name, location, birth_date)
                VALUES(10002, 'James', 'New York',sysdate());
                INSERT INTO person (id, name, location, birth_date)
                VALUES(10003, 'Pieter', 'Amsterdam',sysdate());


        SPRING JDBC TEMPLATE:

            In Spring Jdbc there is a mapper. There is an automatic mapper
            which can be used, when colum names match


            @Repository
            public class PersonJdbcDao {

                @Autowired
                JdbcTemplate jdbcTemplate;
                
                public List<Person> findAll() {
                return jdbcTemplate.query("select * from person", 
                        new BeanPropertyRowMapper<>(Person.class));
                }
            }

            - Whenever we use a BeanPropertyTowMapper, the Bean on which 
              the PropertyRowMapper is defined  should have  a no argument constructor

            @SpringBootApplication
            public class DatabaseDemoApplication implements CommandLineRunner {

                private Logger logger = LoggerFactory.getLogger(this.getClass());

                @Autowired
                PersonJdbcDao dao;

                public static void main(String[] args) {
                    SpringApplication.run(DatabaseDemoApplication.class, args);
                }

                @Override
                public void run(String... args) throws Exception {

                    logger.info("All users -> {}", dao.findAll());
                }
            }

        
DAO CLASS:

            @Repository
            public class PersonJdbcDao {

                @Autowired
                JdbcTemplate jdbcTemplate;

                public List<Person> findAll() {
                return jdbcTemplate.query("select * from person",
                        new BeanPropertyRowMapper<>(Person.class));
                }

                public Person findById(int id) {
                    return jdbcTemplate.queryForObject("select * from person where id=?", new Object[]{id},
                            new BeanPropertyRowMapper<>(Person.class));
                }


                public int  deleteById(int id) {
                    return jdbcTemplate.update("delete from person where id=?", new Object[]{id});
                    //return jdbcTemplate.update("delete from person where id=?, xyz=?", new Object[]{id, xyz});
                    // - for multiple
                }  //return value is - how many rows deleted

                public int insert(Person person) {
                    return jdbcTemplate.update("insert into person (id, name, location, birth_date) "
                            + "values(?,?,?,?)", person.getId(),
                            person.getName(),
                            person.getLocation(),
                            new Timestamp(person.getBirthDate().getTime()));
                }
                public int update(Person person) {
                    return jdbcTemplate.update("update person "
                                    + "set name = ?, location = ?, birth_date = ? "
                                    + "where id = ?",
                            new Object[] {
                                    person.getName(),
                                    person.getLocation(),
                                    new Timestamp(person.getBirthDate().getTime()),
                                    person.getId(),
                            });
                }
            }


BOOT MAIN:

                @SpringBootApplication
                public class DatabaseDemoApplication implements CommandLineRunner {

                    private Logger logger = LoggerFactory.getLogger(this.getClass());

                    @Autowired
                    PersonJdbcDao dao;

                    public static void main(String[] args) {
                        SpringApplication.run(DatabaseDemoApplication.class, args);
                    }

                    @Override
                    public void run(String... args) throws Exception {

                        logger.info("All users -> {}", dao.findAll());
                        logger.info("User id 10001 -> {}", dao.findById(10001));
                        logger.info("Deleting 10002 ->  Rows deleted {}", dao.deleteById(10002));
                        logger.info("Inserting in 10004 -> {}",
                                dao.insert(new Person(10004, "Tara", "Berlin", new Date())));
                        logger.info("Update in 10003 -> {}",
                                dao.update(new Person(10003, "Pieter", "Moscow", new Date())));
                    }
                }

        - So, the complexities in writing the query. 
        - Once you have the query ready, then - all that you need to do is pass in the appropriate 
          parameters and that's all.



    CREATING A CUSTOM SPRING JDBC ROW-MAPPER: 

        BeanPropertyRowMapper<Person>(Person.class);

            - for mapping results of the query  to the bean



            class PersonRowMapper implements RowMapper<Person> {
                @Override
                public Person mapRow(ResultSet rs, int rowNum) throws SQLException {
                    Person person = new Person();
                    person.setId(rs.getInt("id"));
                    person.setName(rs.getString("name"));
                    person.setLocation(rs.getString("location"));
                    person.setBirthDate(rs.getTimestamp("birth_date"));
                    return person;
                }
            }

            public List<Person> findAll() {
            return jdbcTemplate.query("select * from person",
                    new PersonRowMapper());
            }



    JAVA PERSISTENCE API:
        
        - defines set of annotations and set of interfaces
        - Hibernate implements JPA

        @Entity - mapped class

        @Id - Primary key

        - You must have no argument constructor and if you have a constructor
          with parameters, there are must not be id in parameters.


    IMPLEMENTING FINDBYID  JPA REPOSITORY METHOD:

        EntityManager - manages the entities. All the operations you are performing in a specific
                        session - are all stored in the entity manager.

        - All the operations are not really stored in the entity manager, but in
          something called persistent context

        - EntityManager is interface to the persistence context.

        public Person findById(int id) {
            return entityManager.find(Person.class, id);   - what entity, and primary key
        }

        
    FOR H2 CONNECT FROM INTELLIJ IDEA:

        1) Define a bean:

                //@Profile("dev")
                @Bean(initMethod = "start", destroyMethod = "stop")
                public Server h2Server() throws SQLException {
                    return Server.createTcpServer("-tcp", "-tcpAllowOthers", "-tcpPort", "9092");
                }
        
        2) Change H2 Maven-skope:

                		<dependency>
                            <groupId>com.h2database</groupId>
                            <artifactId>h2</artifactId>
                            <!-- <scope>runtime</scope> -->
                        </dependency>

        3) Connection properties:

                url: jdbc:h2:tcp://localhost:9092/mem:testdb
                username: sa 
                password: 

        4) in application properties:

            spring.h2.console.enabled=true
            spring.jpa.show-sql=true


        JPA METHODS:

            find(int id)  - find entity in database

            merge()  - insert or update, if Id is set, hibernate try to update

            remove()   - void method - can't use logger info


        @Repository
        @Transactional
        public class PersonJpaRepository {

            //connect to the database
            @PersistenceContext
            EntityManager entityManager;

            public Person findById(int id) {
                return entityManager.find(Person.class, id);
            }

            public Person update(Person person) {
                return entityManager.merge(person);
            }

            public Person insert(Person person) {
                return entityManager.merge(person);
            }
            public void deleteById(int id) {
                Person person = findById(id);
                entityManager.remove(person);
            }
        }


    
    IMPLEMETING findAll() METHOD  USING JPQL NAMED QUERY:

        - When you create NamedQuery, you need to tell what kind of entity would return . class.

        - Define namedQuery in Entity-class:

            @Entity
            @NamedQuery(name = "find_all_persons", query = "select p from Person p")
            public class Person {

        - Execute NamedQuery in Jparepository:

            public List<Person>  findAll() {
                TypedQuery<Person> namedQuery = entityManager.createNamedQuery("find_all_persons", Person.class);
                return  namedQuery.getResultList();
            }



    SPRING DATA JPA:

        - Spring Data comes in with the concept of predefined repositories

        - It defines something called JPA REPOSITORY for JPA , which we can use to create
          this kind of methods very easily - all of them are predefined inside the Jpa Reposotory.

         - We must follow the conventions , which are used by Spring data when defining methods.
           In Spring Data if there is a method called "find by id". If you pass the Id it will be able 
           to get the data for you. There are no "UPDATE" or "INSERT" methods = only "MERGE"
           and inside the JPA-Repositoty the method is called "SAVE".


            -Defining interface and extending it from JpaRepository<Person, Integer>
                - entity and promary key

            public interface PersonSpringDataRepository extends JpaRepository<Person, Integer> {
            }


            @SpringBootApplication
            public class SpringJpaDemoApplication implements CommandLineRunner {

                private Logger logger = LoggerFactory.getLogger(this.getClass());

                @Autowired
                PersonSpringDataRepository repository;

                public static void main(String[] args) {
                    SpringApplication.run(SpringJpaDemoApplication.class, args);
                }

                @Override
                public void run(String... args) throws Exception {

                    logger.info("\nUser id 10001 -> {}", repository.findById(10001));


                    logger.info("\nInserting 10004 -> {}",
                            repository.save(new Person(10004, "Tara", "Berlin", new Date())));

                    logger.info("\nUpdate 10003 -> {}",
                            repository.save(new Person(10003, "Pieter", "Utrecht", new Date())));

                    repository.deleteById(10002);

                    logger.info("\nAll users -> {}", repository.findAll());

                }
                //@Profile("dev")
                @Bean(initMethod = "start", destroyMethod = "stop")
                public Server h2Server() throws SQLException {
                    return Server.createTcpServer("-tcp", "-tcpAllowOthers", "-tcpPort", "9092");
                }
            }


    CONNECTING TO ANOTHER DATABASES:

            -Very good reference:

            https://github.com/in28minutes/spring-master-class/blob/master/04-spring-jdbc-to-jpa/readme.md

            - Install MySQL and Setup Schema
            - Remove H2 dependency from pom.xml
            - Add MySQL (or your database) dependency to pom.xml

            <dependency>
                <groupId>mysql</groupId>
                <artifactId>mysql-connector-java</artifactId>
            </dependency>

            - Application Properties:

                spring.jpa.hibernate.ddl-auto=none
                spring.datasource.url=jdbc:mysql://localhost:3306/person_example
                spring.datasource.username=personuser
                spring.datasource.password=YOUR_PASSWORD

            spring.jpa.hibernate.ddl-auto is the setting to perform SchemaManagementTool actions automatically
                none : No action will be performed.
                create-only : Database creation will be generated.
                drop : Database dropping will be generated.
                create : Database dropping will be generated followed by database creation.
                validate : Validate the database schema
                update : Update the database schema    

            MySQL grant:

                mysql --user=user_name --password db_name
                create database person_example;
                create user 'personuser'@'localhost' identified by 'YOUR_PASSWORD';
                grant all on person_example.* to 'personuser'@'localhost';



    WEB APPLICATIONS:


        POM.XML FOR SERVLET WEB WITHOUT SPRING:

            <?xml version="1.0" encoding="UTF-8"?>
            <project xmlns="http://maven.apache.org/POM/4.0.0"
                    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
                <modelVersion>4.0.0</modelVersion>

                <groupId>org.example</groupId>
                <artifactId>javaweb</artifactId>
                <version>1.0-SNAPSHOT</version>
                <packaging>war</packaging>

                <dependencies>
            <!--        <dependency>-->
            <!--            <groupId>javax</groupId>-->
            <!--            <artifactId>javaee-web-api</artifactId>-->
            <!--            <version>6.0</version>-->
            <!--            <scope>provided</scope>-->
            <!--        </dependency>-->
                </dependencies>

                <build>
                    <pluginManagement>
                        <plugins>
                            <plugin>
                                <groupId>org.apache.maven.plugins</groupId>
                                <artifactId>maven-compiler-plugin</artifactId>
                                <version>3.8.1</version>
                                <configuration>
                                    <verbose>true</verbose>
                                    <source>11</source>
                                    <target>11</target>
                                    <showWarnings>true</showWarnings>
                                </configuration>
                            </plugin>
                            <plugin>
                                <groupId>org.apache.tomcat.maven</groupId>
                                <artifactId>tomcat9-maven-plugin</artifactId>
                                <version>2.2</version>
                                <configuration>
                                    <path>/</path>
                                    <contextReloadable>true</contextReloadable>
                                </configuration>
                            </plugin>
                        </plugins>
                    </pluginManagement>
                </build>
            </project>


        WEB.XML:

            <!-- webapp/WEB-INF/web.xml -->
            <web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
                    version="3.0">

                <display-name>To do List</display-name>

                <welcome-file-list>
                    <welcome-file>login.do</welcome-file>
                </welcome-file-list>

            </web-app>


        SIMPLE SERVLET:


            @WebServlet(urlPatterns = "/login.do")
            public class LoginServlet extends HttpServlet {

                @Override
                protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
                    PrintWriter out = response.getWriter();
                    out.println("<html>");
                    out.println("<head>");
                    out.println("<title>Yahoo!!!!!!!!</title>");
                    out.println("</head>");
                    out.println("<body>");
                    out.println("My First Servlet");
                    out.println("</body>");
                    out.println("</html>");

                }

            }

        tomcat9-maven-plugin   - automatically downloads and running web-application
                                 in Tomcat.

        maven-compiler-plugin   - compiling classes, and also building Jars and Wars.
                                  default  compiler Java-version is 5.

        Servlet - simply Java class, which can take a request in and can respond back with a response.

        - Any servlet should extend HttpServlet

        - @WebServlet(urlPatterns = "/login.do")

        -doGet()  method is handling GET-requests


        JSP:

            <%@ page contentType="text/html;charset=UTF-8" language="java" %>
            <html>
                <head>
                    <title>Yeah!!! From JSP!!!</title>
                </head>
                <body>
                    JSP READY!!!
                </body>
            </html>

        SERVLET WITH REDIRECT TO JSP PAGE:

            @WebServlet(urlPatterns = "/login.do")
            public class LoginServlet extends HttpServlet {
                @Override
                protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                request.getRequestDispatcher("/WEB-INF/views/login.jsp").forward(request,response);
                }
            }


        




