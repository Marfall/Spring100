https://github.com/in28minutes/spring-master-class

Spring is a Dependency Injection Framework

TYPICAL CODE:

public class ComplexBusinessService {

    SortAlgorithm sortAlgorithm = new BubbleSortAlgorithm();

    // if we want to use another sortAlgorithm, we must modify the code    
    // tight coupling
}

public class BubbleSortAlgorithm implements SortAlgorithm  {

}

REMOVE TIGHT COUPLING:

public class ComplexBusinessService {

    SortAlgorithm sortAlgorithm;

   public ComplexBusinessService(SortAlgorithm sortAlgorithm) {
       this.sortAlgorithm = sortAlgorithm;
   }
}

=> We can write this code:

    //loosely coupled programming 

    SortAlgorithm sortAlgorithm = new SortAlgorithm();
    ComplexBusinessService businessService = 
        new ComplexBusinessService(sortAlgorithm);
        
        
    Spring Framework instantiating  objects and  populate dependencies

    So, your job as a programmer  to tell the Spring  Framework what are the objects it would need 
    to manage and what are the dependencies of each class.


    @Component
    public class ComplexBusinessService {

        @Autowired
        SortAlgorithm sortAlgorithm;
    }

    @Component
    public class BubbleSortAlgorithm implements SortAlgorithm{

    }

    @Component  - tells Spring to start managing it's class instances

    @Autowired  - Spring starts looking for this dependency to fing a matching thing 

    - Spring would make sure that the instances of all the objects it manages
      are created with the dependencies properly populated.

      TERMINOLOGY:

            1) BEANS  -  objects, managing by Spring Framework

            2) AUTOWIRING  - the process where Spring identifies the dependencies,
                            identifies the matches for the dependencies and populates them;

            3) DEPENDENCY INJECTION   - injecting one component to another as a dependency

            4) INVERSION OF CONTROL   - Spring creates an instances 

            5) IOC CONTAINER  -   is a generic terminology to represent anything that is 
                                  implementing inversion of CONTROL

            6) APPLICATION CONTEXT  - IoC Container in Spring Framework


    USING INTERFACES FOR LOOSELY COUPLING:

        public interface SortAlgorithm {
            int[] sort(int[] numbers);
        }

        public class BubbleSortAlgorithm implements SortAlgorithm {
            public int[] sort(int[] numbers) {
                //Logic for Bubble Sort
                return numbers;
            }
        }

        public class BinarySearchImpl {

            private  SortAlgorithm sortAlgorithm;

            public BinarySearchImpl(SortAlgorithm sortAlgorithm) {
                this.sortAlgorithm = sortAlgorithm;
            }

            public int binarySearch(int[] numbers, int numberToSearchFor) {

                int[] sortedNumbers = sortAlgorithm.sort(numbers);
                System.out.println(sortAlgorithm);
                //Search in array
                return 3;
            }
        }

        @SpringBootApplication
        public class Spring100Application {

            public static void main(String[] args) {

                BinarySearchImpl binarySearch = new BinarySearchImpl(new BubbleSortAlgorithm());
                int result = binarySearch.binarySearch(new int[] {12, 4, 6, }, 3);
                System.out.println(result);
                
                SpringApplication.run(Spring100Application.class, args);
            }
        }

        =>  SortAlgorithm -  is a dependency of BinarySearch.
            BinarySearch depends of the SortAlgorithm.
            We male a SortAlgorithm as a separate dependency and passing it 
            into the BinarySearch.
            Then we create an instance of binarySearchImpl and create an instance of quickSort
            and pass it in.


    The most important concepts behind Spring are:
        - Dependency Injection
        - Loose Coupling

    3 questions for begin in Spring Framework:

        - What are te beans?
        - What are the dependencies for the beans
        - Where to search for beans

    @SpringBootApplication - Spring Boot would automatically scan the package (and subpackages) for the beans, where the main
                             application class us present.


    SpringApplication.run(Spring100Application.class, args);

        - run Spring Boot Application, returns ApplicationContext

        => we can make a local variable from it:

    ApplicationContext applicationContext = SpringApplication.run(Spring100Application.class, args);

    BinarySearchImpl binarySearch = applicationContext.getBean(BinarySearchImpl.class);

        - get bean from ApplicationContext


    logging.level.org.springframework = debug
        -set logging level in application.properties


    Also, Spring is searching for beans and their dependencies with  Component Scan.


    DYNAMIC AUTOWIRING AND TROUBLESHOOTING. @PRIMARY:

    - Whenever you have any problems of the type 
        "a bean is not found" or
        "multiple beans are found"

    => See if you have used the right combination of component, autowired and primary. 



    CONSTRUCTOR AND SETTER INJECTION:

        Mandatory Dependency:
            - it is a dependency which it can't work without
            - another - optional dependencies

        If we have mandatory dependencies - the recommendation is
        to use Constructor Injection

        For optional dependencies, recommendation is Setter Injection


    SPRING PROJECTS:

        - Spring Batch
        - Spring Boot
        - Spring Cloud
        - Spring Data
        - Spring Integration
        - Spring Security
        - Spring HATEOAS

    SPRING ADVATAGES:

        - Enables Testable Code
        - No Plumbuing Code
        - Flexible Archicture
        - Staying Current


    DEPENDENCIES EXAMPLES:

        @Component
        public class ToDoController {

            @Autowired
            ToDoBusinessService businessService;
        }

        @Component
        public class ToDoBusinessService {

            @Autowired
            ToDoDataService dataservice;
        }

        @Component
        public class ToDoDataService {

            @Autowired
            JdbcTemplate template;
        }


    AUTOWIRING BY NAME AND PRIMARY:

        @Autowired
        private  SortAlgorithm sortAlgorithm;

        =>

        @Autowired
        private  SortAlgorithm bubleSortAlgorithm;   - variable is a name of class 


    QUALIFIER:

        @Component
        public class BinarySearchImpl {

            @Autowired
            @Qualifier("quick")
            private  SortAlgorithm sortAlgorithm;


            public int binarySearch(int[] numbers, int numberToSearchFor) {

                int[] sortedNumbers = sortAlgorithm.sort(numbers);
                System.out.println(sortAlgorithm);
        
                return 3;
            }
        }


        @Component
        @Qualifier("quick")
        public class QuickSortAlgorithm implements SortAlgorithm {
            public  int[] sort(int[] numbers) {
                
                return numbers;
            }
        }

        => 3 options to resolving multiple candidates for autowiring:

            - Name 
            - @Qualifier
            - @Primary        //recommended way
 

    BEAN SCOPE:

        - Singleton - One instance per Spring Context 
        - Prototype - New bean whenever requested
        - Request - One bean per HTTP request
        - Session - One bean per HTTP session

         Default - Singleton

            @Component
            @Scope("prototype")
            public class BinarySearchImpl {
            }

            Hardcoding "prototype" is not good practice,
            Use ConfigurableBeanFactory:

            @Component
            @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
            public class BinarySearchImpl {
            }


    SLFJ LOGGER:

        private  static Logger LOGGER = LoggerFactory.getLogger(Spring100ScopeApplication.class);


        @SpringBootApplication
        public class Spring100ScopeApplication {

            private  static Logger LOGGER = LoggerFactory.getLogger(Spring100ScopeApplication.class);

            public static void main(String[] args) {

                ApplicationContext applicationContext =
                        SpringApplication.run(Spring100ScopeApplication.class, args);

                PersonDAO personDao = applicationContext.getBean(PersonDAO.class);

                PersonDAO personDao2 = applicationContext.getBean(PersonDAO.class);

                LOGGER.info("{}",personDao);
                LOGGER.info("{}",personDao.getJdbcConnection());

                LOGGER.info("{}",personDao2);
                LOGGER.info("{}",personDao2.getJdbcConnection());
            }
        }

        CBF + TAB = ConfigurableBeanFactory


        @Component
        public class PersonDAO {

            @Autowired
            JdbcConnection jdbcConnection;

            public JdbcConnection getJdbcConnection() {
                return jdbcConnection;
            }

            public void setJdbcConnection(JdbcConnection jdbcConnection) {
                this.jdbcConnection = jdbcConnection;
            }
        }


        @Component
        @Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE, proxyMode = ScopedProxyMode.TARGET_CLASS)
        public class JdbcConnection {

            public JdbcConnection() {
                System.out.println("JDBC Connection ");
            }
        }

        proxyMode = ScopedProxyMode.TARGET_CLASS

            - create a new object in every request  (proxy)

            => every time , when JdbcConnection is used, it would start using a proxy
               and whenever there is a request, you make sure that there is a new JdbcConnection beeing used.


        => When you trying to get a singleton - bean and one of it's dependencies is a prototype,
           then on the dependency, we should use a proxy.



    DIFFERENCE BETWEEN SPRING SINGLETON AND  GOF SINGLETON:

        - GOF Singleton means - One Singleton per JVM;
        - Spring Singleton -  One instance per Application Context


    USING COMPONENT SCAN:

        @SpringBootApplication includes:

            - @ComponentScan
            - @Configuration
            - @EnabeAutoConfiguration  


        - @ComponentScan("com.in28minutes,spring.basics")  - scan for components in package



    LIFECYCLE OF A BEAN - @PostConstruct and  @PreDestroy:

        - @PostConstruct would be called when the bean is created.
          So, as soon as the bean is created and initialized with the dependencies,
          the postConstruct method would be called.

        - @PreDestroy method called when the bean is removed out of context.
         

            @Component
            @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)
            public class BinarySearchImpl {

                private Logger logger = LoggerFactory.getLogger(this.getClass());

                @Autowired
                @Qualifier("quick")
                private  SortAlgorithm sortAlgorithm;
                
                public int binarySearch(int[] numbers, int numberToSearchFor) {

                    int[] sortedNumbers = sortAlgorithm.sort(numbers);
                    System.out.println(sortAlgorithm);
                    return 3;
                }

                @PostConstruct
                public void postConstruct() {
                    logger.info("postConstruct");
                }
                @PreDestroy
                public void preDestroy() {
                    logger.info("preDestroy");

                }
            }


    CDI - CONTEXT AND DEPENDENCY INJECTION:

        - Java EE Dependency Injection Standart (JSR-330) - ia an Interface defining how to do DI.
        - Spring supports CDI

        - @Inject (@Autowired).
        - @Named (@Component and @Qualifier)
        - @Singleton (Desines a scope of Singleton)
        
        Maven Dependency for CDI:

        <dependency>
            <groupId>javax.inject</groupId>
            <artifactId>javax.inject</artifactId>
            <version>1</version>
        </dependency>


    REMOVING SPRING BOOT IN APPLICATION:

        - removing spring boot starter dependency on spring-core and spring-context

            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter</artifactId>
            </dependency>       
            
            -   <dependency>
                    <groupId>org.springframework</groupId>
                    <artifactId>spring-core/artifactId>
                </dependency>
        
        - Add @Configuration, add ApllicationContext:
            AnnotationConfigApplicationContext = ACAC + TAB


            ApplicationContext applicationContext =
				new AnnotationConfigApplicationContext(Spring100BasicApplication.class);

        - Add ComponentScan:

            @ComponentScan("com.outspace.spring.spring100")

        - Add dependency for SLF4j:

            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-context</artifactId>
		    </dependency>

        - If @PostConstruct and @PreDestroy not working, add javax.annotation-api as dependency:

                <dependency>
                    <groupId>javax.annotation</groupId>
                    <artifactId>javax.annotation-api</artifactId>
                </dependency>



        ADD LOGBACK AND CLOSE APPLICATION CONTEXT:


            ConfigurableApplicationContext applicationContext =
				new AnnotationConfigApplicationContext(Spring100BasicApplication.class);

            applicationContext.close();


            another way - try-catch with resources:

            @Configuration
            @ComponentScan("com.outspace.spring.spring100")
            public class Spring100BasicApplication {

                public static void main(String[] args) {

                    try (ConfigurableApplicationContext applicationContext =
                            new AnnotationConfigApplicationContext(Spring100BasicApplication.class)) {

                        BinarySearchImpl binarySearch = applicationContext.getBean(BinarySearchImpl.class);
                        BinarySearchImpl binarySearch1 = applicationContext.getBean(BinarySearchImpl.class);

                        System.out.println(binarySearch);
                        System.out.println(binarySearch1);

                        int result = binarySearch.binarySearch(new int[]{12, 4, 6,}, 3);

                        System.out.println(result);
                    }
                }
            }


        - problem with log4j resolved with dependency:

                <dependency>
                    <groupId>ch.qos.logback</groupId>
                    <artifactId>logback-classic</artifactId>
                </dependency>



        DEFINING SPRING APPLICATION CONTEXT USING XML:

            -we  need to create applicationContext.xml in src/main/resources

            <?xml version="1.0" encoding="UTF-8"?>
            <beans xmlns="http://www.springframework.org/schema/beans"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
                
                <bean id="xmlJdbcConnection"
                    class="com.outspace.spring.spring100.xml.XMLJdbcConnection">
                </bean>
                <bean id="xmlPersonDAO"
                    class="com.outspace.spring.spring100.xml.XMLPersonDAO">
                    <property name="xmlJdbcConnection" ref="xmlJdbcConnection"/>
                </bean>
            </beans>

            public class XMLPersonDAO {
                
                XMLJdbcConnection xmlJdbcConnection;

                public XMLJdbcConnection getXmlJdbcConnection() {
                    return xmlJdbcConnection;
                }

                public void setXmlJdbcConnection(XMLJdbcConnection xmlJdbcConnection) {
                    this.xmlJdbcConnection = xmlJdbcConnection;
                }
            }

            public class XMLJdbcConnection {

                public XMLJdbcConnection() {
                    System.out.println("JDBC Connection ");
                }
            }


        MIXING XML CONEXT AND JAVA CONFIG:

            applicationContext.getBeanDefinitionNames();

                - What are the beans are loaded by this applicationContext


            LOGGER.info("Beans Loaded -> {}",
                        (Object)applicationContext.getBeanDefinitionNames());

                -  get an array of defined beans (without Object-casting - only one)

            
            CHANGE SCHEMA:

                <?xml version="1.0" encoding="UTF-8"?>
                <beans xmlns="http://www.springframework.org/schema/beans"
                    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                    xmlns:context="http://www.springframework.org/schema/context"
                    xsi:schemaLocation="http://www.springframework.org/schema/beans
                        http://www.springframework.org/schema/beans/spring-beans.xsd
                        http://www.springframework.org/schema/context
                        http://www.springframework.org/schema/context/spring-context.xsd">

                    <context:component-scan base-package="com.outspace.spring.spring100"/>

                    <bean id="xmlJdbcConnection"
                        class="com.outspace.spring.spring100.xml.XMLJdbcConnection">
                    </bean>
                    <bean id="xmlPersonDAO"
                        class="com.outspace.spring.spring100.xml.XMLPersonDAO">
                        <property name="xmlJdbcConnection" ref="xmlJdbcConnection"/>
                    </bean>
                </beans>


            IOC-CONTAINER, APPLICATION CONTEXT, BEAN FACTORY:

                IoC container - is a generic concept

                - There are 2 implementations of IoC in Spring:

                    - BeanFactory           - basic management for beans and wiring the dependencies
                    - ApplicationContext   // recommended

                        - BeanFactory++
                            - Spring's AOP  features
                            - |18n capabilities
                            - WebApplicationContext for web applications etc             
                            - provides Internationalization - can customize the text, based on the
                              locale of user


            @COMPONENT VS @SERVICE VS @REPOSITORY VS @CONTROLLER:

                @Component - Generic Component

                @Repository - encapsulating storage, retrieval and search behaviour typically
                            from a relational database.
                            Provides a default JDBC-exeptions translation facility.

                @Service - Business Service Facade
                            - With Sprong AOP you can identify and log all of the content that coming in.
                            

                @Controller - Controller in MVC pattern



        READ VALUES FROM  EXTERNAL PROPERTIES FILE:

            1) create file app.properties in resources and add something like:

                external.service.url=hhtp://someserver.dev.com/service
            
            2) add      @Value("${external.service.url}")
                        private String url;

                It's configuring when context is creating.
                @PropertySource("classpath:app.properties")   - defining properties source


                @Configuration
                @ComponentScan("com.outspace.spring.spring100")
                @PropertySource("classpath:app.properties")
                public class Spring100PropertiesApplication {

                    public static void main(String[] args) {

                        try (ConfigurableApplicationContext applicationContext =
                                new AnnotationConfigApplicationContext(Spring100PropertiesApplication.class)) {

                            SomeExternalService someExternalService =
                                    applicationContext.getBean(SomeExternalService.class);
                            
                            System.out.println("CURRENT URL: " + someExternalService.returnServiceURL());
                        }
                    }
                }

                @Service
                public class SomeExternalService {

                    // from property file external.service.url
                    @Value("${external.service.url}")
                    private String url;

                    public String returnServiceURL() {
                        return url;
                    }
                }


                

        JUNIT TESTING:

            - It's testing a specific method or a specific class or group of methods;

            @Test - method contains Unit Test

            import org.junit.jupiter.api.Test;

            import static org.junit.jupiter.api.Assertions.assertEquals;

            class MyMathTest {

                //MyMath.sum
                // 1,2,3 => 6

                @Test
                public  void sum_with3numbers() {
                    MyMath myMath = new MyMath();
                    int result = myMath.sum(new int[] {1, 2, 3});

                    //check that result is 6
                    //check result==6
                    
                    assertEquals(6, result);

                    System.out.println(result);
                }
            }


                @Test
                public void test() {
                    boolean cond = true;
                    assertEquals(true, cond);
                    assertTrue(cond);
                    assertFalse(cond);
                    assertNotNull(Object object);
                    assertArrayEquals(expecteds, actuals);
                }
            }
             

            @BeforeEach - will be running before every test

            @BeforeAll - it's a class annotation, runs one time for every class (and static method)



            import static org.junit.jupiter.api.Assertions.assertEquals;

            class MyMathTest {

                @BeforeEach
                public void before() {
                    System.out.println("Before test");
                }
                @AfterAll
                public static void after() {
                    System.out.println("After test");
                }
                @Test
                public  void sum_with3numbers() {
                    System.out.println("Test1");
                    MyMath myMath = new MyMath();
                    int result = myMath.sum(new int[] {1, 2, 3});
                    assertEquals(6, result);
                    System.out.println(result);
                }
                @Test
                public void sum_with1number() {
                    System.out.println("Test2");
                    assertEquals(3,new MyMath().sum(new int[] {3}));
                }
            }


        MOCKITO:

        When we are using Mocks we don't really need to create multiple versions to make it 
        really easy to dynamically create different classes and make them return the data
        that we would want to return.

            WITHOUT MOCK EXAMPLE:

                public class SomeBusinessTest {

                    @Test
                    public void testFindTheGreatestFromAllData() {

                        SomeBusinessImpl businessImpl = new SomeBusinessImpl(new DataServiceStub());
                        int result = businessImpl.findTheGreatestFromAllData();
                        assertEquals(24, result);
                    }
                }

                class DataServiceStub implements DataService {
                    @Override
                    public int[] retrieveAllData() {
                        return new int[] {4, 6, 15};
                    }
                }


        USING MOKITO:

            package com.mockito100.mockitodemo;

            import org.junit.jupiter.api.Test;

            import static org.junit.jupiter.api.Assertions.assertEquals;
            import static org.mockito.Mockito.mock;
            import static org.mockito.Mockito.when;

            public class SomeBusinessMockTest {

                @Test
                public void testFindTheGreatestFromAllData() {

                    DataService dataServiceMock = mock(DataService.class);

                    when(dataServiceMock.retrieveAllData()).thenReturn(new int[] {24, 15, 3});

                    SomeBusinessImpl businessImpl = new SomeBusinessImpl(dataServiceMock);
                    int result = businessImpl.findTheGreatestFromAllData();
                    assertEquals(24, result);
                }

                @Test
                public void testFindTheGreatestFromAllData_ForOneValue() {

                    DataService dataServiceMock = mock(DataService.class);

                    when(dataServiceMock.retrieveAllData()).thenReturn(new int[] {15});

                    SomeBusinessImpl businessImpl = new SomeBusinessImpl(dataServiceMock);
                    int result = businessImpl.findTheGreatestFromAllData();
                    assertEquals(24, result);
                }
            }





    MOCKITO ANNOTATIONS @MOCK, @INJECTMOKS, @RUNWITH